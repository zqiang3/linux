## 链接

https://www.cnblogs.com/liuwanpeng/p/6246050.html

https://blog.csdn.net/qq_29350001/article/details/65437279

## 引言

几个I/O函数：open, read, write, lseek和close，这些函数不带缓冲，是对内核的系统调用。

多进程共享资源(包括文件)时，会有很多额外的烦恼，需要对共享资源、原子操作等概念深入理解，需要理解涉及的内核有关数据结构，这些数据结构对理解文件、共享有重要作用

最后介绍dup, dup2, fcntl, sync, fsync和ioctl函数

## 文件描述符

内核用文件(fd)描述符标识**进程正在访问的文件**，文件描述符通常是一个非负整数。fd是动态分配的，优先分配未使用的最小值。

新进程执行时，shell会默认分配三个文件描述符，STDIN_FILENO/STDOUT_FILENO/STDERR_FILENO,一般为0/1/2，定义在<unistd.h>中



## read

```c
ssize_t read(int fd, void * buf, size_t count);
```

**说明**

read()会把参数fd所指的文件传送count 个字节到buf 指针所指的内存中 

**返回值**

成功返回读到的字节数；如果返回0, 表示已到达文件尾或是无可读取的数据；出错返回-1

多种情况会导致读到的字节数少于要求读的字节数：
1. 没读够就到文件尾了。例如想要100bytes，但到文件尾还有30bytes，会返回30（实际读到的字节数）；
2. 已到文件尾，返回0（实际读到的字节数）
3. 从特殊文件读，有限制：
    终端设备，通常最多1行；
    网络设备，缓冲机制能到导致没有那么多数据可读；
    管道或FIFO，没那么多数据可读；
    某些记录设备，一次最多返回1个记录；
4. 读时被信号中断

## write

```c
ssize_t write (int fd, const void * buf, size_t count);
```

**说明**

write()会把参数buf所指的内存写入count个字节到参数放到所指的文件内 

**返回值**

成功返回写入的字节数；出错返回-1，并写errno。

出错原因一般是磁盘满或超过文件长度限制

## 内核IO相关的数据结构

进程表项（包括文件描述符列表，指向文件表项）

文件表项，包含v节点指针

v节点表项。

**文件表项**

内核为所有打开文件维持一张文件表，包括:

1. 文件状态标志（读、写、添写、同步和非阻塞等）
2. 文件当前偏移量
3. 指向该文件V节点的指针（linux没有V节点）

**v-node与i-node**

每个文件都有，保存在磁盘上，与文件对应，打开文件时获取的，主要包括文件的所有者、文件长度、指向文件实际数据块在磁盘所在位置的指针等。

v-node是与文件系统无关的，所以单独提出来。linux里没有v-node，而是采用**“与文件系统无关的i节点”+“与文件系统有关的i节点”**的方式。

## fcntl

代码见test_fcntl.c

```
./a.out 0 < /dev/tty
./a.out 1 > temp
./a.out 1 >> temp  # 追加重定向
./a.out 5 5<>temp  # 在文件描述符5上打开文件， <>是可读可写
./a.out 5 5>temp   # 在文件描述符5上打开文件， >是可写
./a.out 5 5<temp   # 在文件描述符5上打开文件， >是可读
```

