## 操作系统线程模型

当线程在用户空间下实现时，操作系统对线程的存在一无所知，操作系统只能看到进程，而不能看到线程。所有的线程都是在用户空间实现。在操作系统看来，每一个进程只有一个线程。过去的操作系统大部分是这种实现方式，这种方式的好处之一就是即使操作系统不支持线程，也可以通过库函数来支持线程。

我们换一种通俗的方式来讲解这段话，首先就是在这在模型下，**程序员需要自己实现线程的数据结构、创建销毁和调度维护。也就相当于需要实现一个自己的线程调度内核**，而同时这些线程运行在操作系统的一个进程内，最后操作系统直接对进程进行调度。

**优点**

首先就是**确实在操作系统中实现了真实的多线程**，其次就是线**程的调度只是在用户态，减少了操作系统从内核态到用户态的切换开销。**

**缺点**

这种模式最致命的缺点也是由于操作系统不知道线程的存在，因此当一个进程中的某一个线程进行系统调用时，比如缺页中断而导致线程阻塞，此时操作系统会阻塞整个进程，即使这个进程中其它线程还在工作。还有一个问题是假如进程中一个线程长时间不释放CPU，因为用户空间并没有时钟中断机制，会导致此进程中的其它线程得不到CPU而持续等待。



Synchronous programing model is simpler than an asynchronous one.

pthread_create 并不 像其他POSIX函数那样 设置errno 



A thread can exit in three ways

return

be canceled by another thread in the same process

call pthread_exit



